#![allow(missing_docs)]
// temporary while we figure out what should be public in the end
/// Four section dictionary.
use crate::dict_sect_pfc;
use crate::triples::Id;
use crate::{ControlInfo, DictSectPFC};
use log::error;
use std::collections::HashSet;
use std::io::BufRead;
use std::thread::JoinHandle;
use thiserror::Error;

pub type Result<T> = core::result::Result<T, Error>;

/// Position in an RDF triple.
#[derive(Debug, Clone, Copy)]
pub enum IdKind {
    /// IRI or blank node in the first position of a triple.
    Subject,
    /// IRI in the second position of a triple.
    Predicate,
    /// IRI, blank node or literal in the third position of a triple.
    Object,
}

impl IdKind {
    pub const KINDS: [IdKind; 3] = [IdKind::Subject, IdKind::Predicate, IdKind::Object];
}

/// Four section dictionary with plain front coding.
/// Dictionary with shared, subject, predicate and object sections.
/// Types specified as <http://purl.org/HDT/hdt#dictionaryFour>.
/// See <https://www.rdfhdt.org/hdt-internals/#dictionary>.
#[cfg_attr(test, derive(PartialEq))]
#[derive(Debug)]
pub struct FourSectDict {
    /// The shared section contains URIs that occur both in subject and object position. Its IDs start at one.
    pub shared: DictSectPFC,
    /// URIs that only occur as subjects. Their IDs start at the last ID of the shared section + 1.
    pub subjects: DictSectPFC,
    /// The predicate section has its own separate numbering starting from 1.
    pub predicates: DictSectPFC,
    /// URIs and literals that only occur as objects . Their IDs start at the last ID of the shared section + 1.
    pub objects: DictSectPFC,
}

/// Designates one of the four sections.
#[derive(Debug)]
pub enum SectKind {
    /// section for terms that appear as both subject and object
    Shared,
    /// section for terms that only appear as subjects
    Subject,
    /// section for terms that only appear as predicates
    Predicate,
    /// sections for terms that only appear as objects
    Object,
}

/// Wraps an extraction error with additional information on which dictionary section it occurred in.
#[derive(Error, Debug)]
#[error("four sect dict error id_to_string({id},IdKind::{id_kind:?}) in the {sect_kind:?} section, caused by {e}")]
pub struct ExtractError {
    #[source]
    e: dict_sect_pfc::ExtractError,
    id: Id,
    id_kind: IdKind,
    sect_kind: SectKind,
}

#[derive(Error, Debug)]
#[error("four sect dict section error in the {sect_kind:?} section")]
pub struct DictSectError {
    #[source]
    e: dict_sect_pfc::Error,
    sect_kind: SectKind,
}

#[derive(Error, Debug)]
pub enum Error {
    #[error("failed to read FourSectDict control info")]
    ControlInfo(#[from] crate::containers::control_info::Error),
    #[error("failed to read FourSectDict section")]
    DictSect(#[from] DictSectError),
    #[error("failed to read FourSectDict: {0}")]
    Other(String),
}

#[derive(Debug, PartialEq, Eq, Hash)]
pub struct EncodedTripleId {
    pub subject: Id,
    pub predicate: Id,
    pub object: Id,
}

impl FourSectDict {
    /// Get the string value of a given ID of a given type.
    /// String representation of URIs, literals and blank nodes is defined in <https://www.w3.org/Submission/2011/SUBM-HDT-20110330/#dictionaryEncoding>>..
    pub fn id_to_string(&self, id: Id, id_kind: IdKind) -> core::result::Result<String, ExtractError> {
        use SectKind::*;
        let shared_size = self.shared.num_strings() as Id;
        let d = id.saturating_sub(shared_size);
        match id_kind {
            IdKind::Subject => {
                if id <= shared_size {
                    self.shared.extract(id).map_err(|e| ExtractError { e, id, id_kind, sect_kind: Shared })
                } else {
                    self.subjects.extract(d).map_err(|e| ExtractError { e, id, id_kind, sect_kind: Subject })
                }
            }
            IdKind::Predicate => {
                self.predicates.extract(id).map_err(|e| ExtractError { e, id, id_kind, sect_kind: Predicate })
            }
            IdKind::Object => {
                if id <= shared_size {
                    self.shared.extract(id).map_err(|e| ExtractError { e, id, id_kind, sect_kind: Shared })
                } else {
                    self.objects.extract(d).map_err(|e| ExtractError { e, id, id_kind, sect_kind: Object })
                }
            }
        }
    }

    /// Get the ID for a given string or 0 if not found.
    /// String representation of URIs, literals and blank nodes is defined in <https://www.w3.org/Submission/2011/SUBM-HDT-20110330/#dictionaryEncoding>>..
    pub fn string_to_id(&self, s: &str, id_kind: IdKind) -> Id {
        let shared_size = self.shared.num_strings();
        match id_kind {
            IdKind::Subject => {
                let mut id = self.shared.string_to_id(s);
                if id == 0 {
                    id = self.subjects.string_to_id(s);
                    if id > 0 {
                        id += shared_size as Id;
                    }
                }
                id
            }
            IdKind::Predicate => self.predicates.string_to_id(s),
            IdKind::Object => {
                let mut id = self.shared.string_to_id(s);
                if id == 0 {
                    id = self.objects.string_to_id(s);
                    if id > 0 {
                        id += shared_size as Id;
                    }
                }
                id
            }
        }
    }

    /// read the whole dictionary section including control information
    pub fn read<R: BufRead>(reader: &mut R) -> Result<UnvalidatedFourSectDict> {
        use SectKind::*;
        let dict_ci = ControlInfo::read(reader)?;
        if dict_ci.format != "<http://purl.org/HDT/hdt#dictionaryFour>" {
            return Err(Error::Other("Implementation only supports four section dictionaries".to_owned()));
        }
        let mut f = |sect_kind| DictSectPFC::read(reader).map_err(|e| DictSectError { e, sect_kind });
        Ok(UnvalidatedFourSectDict([f(Shared)?, f(Subject)?, f(Predicate)?, f(Object)?]))
    }

    /// Parse N-Triples and collect terms into sets
    /// *This function is available only if HDT is built with the `"sophia"` feature, included by default.*
    #[cfg(feature = "sophia")]
    pub fn parse_nt_terms<R: BufRead>(
        r: &mut R,
    ) -> Result<(
        Vec<(String, String, String)>,
        std::collections::BTreeSet<String>,
        std::collections::BTreeSet<String>,
        Vec<String>,
    )> {
        use sophia::api::prelude::TripleSource;
        use sophia::turtle::parser::nt;
        use std::collections::BTreeSet;
        use std::ops::Deref;
        use std::thread;

<<<<<<< HEAD
        let mut raw_triples = Vec::new(); // Store raw triples

        // TODO: compare times with Vec followed by parallel sort vs times with BTreeSet
        let mut subject_terms = HashSet::<String>::new();
        let mut object_terms = HashSet::<String>::new();
=======
        let mut raw_triples = Vec::new();
        let mut subject_terms = BTreeSet::<String>::new();
        let mut object_terms = BTreeSet::<String>::new();
>>>>>>> 449f8cb (create separate function in FourDictSect::read_nt)
        let mut predicate_terms = Vec::<String>::new();
        nt::parse_bufread(r)
            .for_each_triple(|q| {
                // HDT does not have angled brackets around IRIs
                let clean = |s: &mut String| {
                    let mut chars = s.chars();
                    if chars.nth(0) == Some('<') && chars.nth_back(0) == Some('>') {
                        s.remove(0);
                        s.pop();
                    }
                };
                let mut subj_str = q.subject.to_string();
                clean(&mut subj_str);
                let mut pred_str = q.predicate.to_string();
                clean(&mut pred_str);
                let mut obj_str = q.object.to_string();
                clean(&mut obj_str);

                subject_terms.insert(subj_str.clone());
                predicate_terms.push(pred_str.clone());
                object_terms.insert(obj_str.clone());

                raw_triples.push((subj_str, pred_str, obj_str));
            })
            .map_err(|e| Error::Other(format!("Error reading N-Triples: {e:?}")))?;

        raw_triples.sort_unstable();
        raw_triples.dedup();

        Ok((raw_triples, subject_terms, object_terms, predicate_terms))
    }

    /// Build dictionary from collected terms
    /// *This function is available only if HDT is built with the `"sophia"` feature, included by default.*
    #[cfg(feature = "sophia")]
    pub fn build_dict_from_terms(
        subject_terms: std::collections::BTreeSet<String>, object_terms: std::collections::BTreeSet<String>,
        predicate_terms: Vec<String>, block_size: usize,
    ) -> Self {
        use log::warn;
        use std::collections::BTreeSet;

        if predicate_terms.is_empty() {
            warn!("no triples found in provided RDF");
        }
<<<<<<< HEAD
        let sorter = thread::Builder::new()
            .name("sorter".to_owned())
            .spawn(move || {
                raw_triples.sort_unstable(); // Faster than stable sort
                raw_triples.dedup();
                raw_triples
            })
            .unwrap();
=======
        let predicate_terms_ref: BTreeSet<&str> = predicate_terms.iter().map(std::ops::Deref::deref).collect();
>>>>>>> 449f8cb (create separate function in FourDictSect::read_nt)

        let [shared, subjects, predicates, objects]: [DictSectPFC; 4] = std::thread::scope(|s| {
            [
                s.spawn(|| {
                    let shared_terms: BTreeSet<&str> =
                        subject_terms.intersection(&object_terms).map(Deref::deref).collect();
                    DictSectPFC::compress(&shared_terms, block_size)
                }),
                s.spawn(|| {
                    let unique_subject_terms = subject_terms.difference(&object_terms).map(Deref::deref).collect();
                    DictSectPFC::compress(&unique_subject_terms, block_size)
                }),
                s.spawn(|| {
                    let predicate_terms_ref: BTreeSet<&str> = predicate_terms.iter().map(Deref::deref).collect();
                    DictSectPFC::compress(&predicate_terms_ref, block_size)
                }),
                s.spawn(|| {
                    let unique_object_terms = object_terms.difference(&subject_terms).map(Deref::deref).collect();
                    DictSectPFC::compress(&unique_object_terms, block_size)
                }),
            ]
            .map(|t| t.join().unwrap())
        });

<<<<<<< HEAD
        let dict = FourSectDict { shared, subjects, predicates, objects };

        let sorted_triples = sorter.join().unwrap();
        let slice: &[(String, String, String)] = &sorted_triples;
        // encode triples using rayon's parallel iterator
        let encoded_triples: Vec<TripleId> = slice
            .par_iter()
            .map(|(s, p, o)| {
                let triple = [
                    dict.string_to_id(s, IdKind::Subject),
                    dict.string_to_id(p, IdKind::Predicate),
                    dict.string_to_id(o, IdKind::Object),
=======
        // Parallelize dictionary compression using rayon
        let ((shared, predicates), (subjects, objects)) = rayon::join(
            || {
                rayon::join(
                    || DictSectPFC::compress(&shared_terms, block_size),
                    || DictSectPFC::compress(&predicate_terms_ref, block_size),
                )
            },
            || {
                rayon::join(
                    || DictSectPFC::compress(&unique_subject_terms, block_size),
                    || DictSectPFC::compress(&unique_object_terms, block_size),
                )
            },
        );

        FourSectDict { shared, predicates, subjects, objects }
    }

    /// Encode raw triples to IDs using dictionary
    /// *This function is available only if HDT is built with the `"sophia"` feature, included by default.*
    #[cfg(feature = "sophia")]
    pub fn encode_triples(&self, raw_triples: Vec<(String, String, String)>) -> Vec<crate::triples::TripleId> {
        use log::error;
        use rayon::prelude::*;

        raw_triples
            .into_par_iter()
            .map(|(s, p, o)| {
                let triple = [
                    self.string_to_id(&s, IdKind::Subject),
                    self.string_to_id(&p, IdKind::Predicate),
                    self.string_to_id(&o, IdKind::Object),
>>>>>>> 449f8cb (create separate function in FourDictSect::read_nt)
                ];
                if triple[0] == 0 || triple[1] == 0 || triple[2] == 0 {
                    error!("{triple:?} contains 0, part of ({s}, {p}, {o}) not found in the dictionary");
                }
                triple
            })
            .collect()
    }

    /// read N-Triples and convert them to a dictionary and triple IDs
    /// *This function is available only if HDT is built with the `"sophia"` feature, included by default.*
    #[cfg(feature = "sophia")]
    pub fn read_nt<R: BufRead>(r: &mut R, block_size: usize) -> Result<(Self, Vec<crate::triples::TripleId>)> {
        use log::info;

        // 1. Parse N-Triples and collect terms
        let timer = std::time::Instant::now();
        let (raw_triples, subject_terms, object_terms, predicate_terms) = Self::parse_nt_terms(r)?;
        let parse_time = timer.elapsed();

        // 2. Build dictionary from terms
        let timer = std::time::Instant::now();
        let dict = Self::build_dict_from_terms(subject_terms, object_terms, predicate_terms, block_size);
        let dict_build_time = timer.elapsed();

        // 3. Encode triples to IDs using dictionary
        let timer = std::time::Instant::now();
        let encoded_triples = dict.encode_triples(raw_triples);
        info!("{parse_time:?},{dict_build_time:?},{:?}", timer.elapsed());

        Ok((dict, encoded_triples))
    }

    /// write the whole Dictionary including control info and all sections
    pub fn write(&self, write: &mut impl std::io::Write) -> Result<()> {
        use SectKind::*;
        ControlInfo::four_sect_dict().write(write)?;
        self.shared.write(write).map_err(|e| DictSectError { e, sect_kind: Shared })?;
        self.subjects.write(write).map_err(|e| DictSectError { e, sect_kind: Subject })?;
        self.predicates.write(write).map_err(|e| DictSectError { e, sect_kind: Predicate })?;
        self.objects.write(write).map_err(|e| DictSectError { e, sect_kind: Object })?;
        Ok(())
    }

    /// size in bytes of the in memory four section dictionary
    pub fn size_in_bytes(&self) -> usize {
        self.shared.size_in_bytes()
            + self.subjects.size_in_bytes()
            + self.predicates.size_in_bytes()
            + self.objects.size_in_bytes()
    }
}

/// A wrapper to ensure prevent using FourSectDict before its checksums have been validated
pub struct UnvalidatedFourSectDict([JoinHandle<dict_sect_pfc::Result<DictSectPFC>>; 4]);

impl UnvalidatedFourSectDict {
    /// Validates the checksums of all dictionary sections in parallel.
    /// Dict validation takes around 1200 ms on a single thread with an 1.5 GB HDT file on an i9-12900k.
    pub fn validate(self) -> Result<FourSectDict> {
        use SectKind::*;
        let r: Vec<_> = [Shared, Subject, Predicate, Object]
            .into_iter()
            .zip(self.0)
            .map(|(sect_kind, handle)| handle.join().unwrap().map_err(|e| DictSectError { e, sect_kind }))
            .collect::<std::result::Result<Vec<DictSectPFC>, DictSectError>>()?;
        let [shared, subjects, predicates, objects]: [DictSectPFC; 4] = r.try_into().unwrap();
        Ok(FourSectDict { shared, subjects, predicates, objects })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::header::Header;
    use crate::tests::init;
    use fs_err::File;
    use pretty_assertions::assert_eq;
    use std::io::BufReader;

    #[test]
    fn read_write_dict() -> color_eyre::Result<()> {
        init();
        let file = File::open("tests/resources/snikmeta.hdt")?;
        let mut reader = BufReader::new(file);
        ControlInfo::read(&mut reader)?;
        Header::read(&mut reader)?;

        let dict = FourSectDict::read(&mut reader)?.validate()?;
        assert_eq!(dict.shared.num_strings(), 43, "wrong number of strings in the shared section");
        assert_eq!(dict.subjects.num_strings(), 6, "wrong number of strings in the subject section");
        assert_eq!(dict.predicates.num_strings(), 23, "wrong number of strings in the predicates section");
        assert_eq!(dict.objects.num_strings(), 133, "wrong number of strings in the objects section");
        assert_eq!(dict.string_to_id("_:b1", IdKind::Subject), 1);
        assert_eq!("http://www.snik.eu/ontology/meta/uses", dict.id_to_string(43, IdKind::Subject)?);
        assert_eq!("http://www.snik.eu/ontology/meta/Chapter", dict.id_to_string(3, IdKind::Subject)?);
        assert_eq!("http://www.snik.eu/ontology/meta/DataSetType", dict.id_to_string(5, IdKind::Subject)?);
        for id in 1..dict.shared.num_strings() {
            let s = dict.id_to_string(id, IdKind::Subject)?;
            let back = dict.string_to_id(&s, IdKind::Subject);
            assert_eq!(id, back, "shared id {} -> subject {} -> id {}", id, s, back);

            let s = dict.id_to_string(id, IdKind::Object)?;
            let back = dict.string_to_id(&s, IdKind::Object);
            assert_eq!(id, back, "shared id {} -> object {} -> id {}", id, s, back);
        }
        for (sect, kind, name, offset) in [
            (&dict.subjects, IdKind::Subject, "subject", dict.shared.num_strings()),
            (&dict.objects, IdKind::Object, "object", dict.shared.num_strings()),
            (&dict.predicates, IdKind::Predicate, "predicate", 0),
        ] {
            for id in offset + 1..offset + sect.num_strings() {
                let s = dict.id_to_string(id, kind)?;
                let back = dict.string_to_id(&s, kind);
                assert_eq!(id, back, "{} id {} -> {} {} -> id {}", name, id, name, s, back);
            }
        }
        let mut buf = Vec::new();
        dict.write(&mut buf)?;
        let dict2 = FourSectDict::read(&mut std::io::Cursor::new(buf))?.validate()?;
        assert_eq!(dict, dict2);
        Ok(())
    }
}
